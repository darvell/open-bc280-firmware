#!/usr/bin/env bash
set -euo pipefail

# Headless Renode smoke test:
# 1) builds open-firmware
# 2) runs bc280_open_firmware.resc via Renode
# 3) asserts UART1 prints at least one "[open-fw] t=" status line

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
RENODE_RESC="$ROOT_DIR/renode/bc280_open_firmware.resc"
SIM_SECONDS="${RENODE_SMOKE_SIM_SECONDS:-3}"
TIMEOUT_SECONDS="${RENODE_SMOKE_TIMEOUT:-60}"

# Optional: pause between launch and log polling (gives Renode time to start CPU).
LAUNCH_GRACE_MS="${RENODE_SMOKE_GRACE_MS:-500}"

find_renode() {
    local native_candidates=()
    local exe_candidates=()
    local app_candidates=()
    local path_bin

    [[ -n "${RENODE_BIN:-}" ]] && native_candidates+=("$RENODE_BIN")
    [[ -n "${RENODE:-}" ]] && native_candidates+=("$RENODE")
    [[ -n "${RENODE_APP:-}" ]] && app_candidates+=("$RENODE_APP")
    app_candidates+=("$ROOT_DIR/renode/Renode.app")
    app_candidates+=("/Applications/Renode.app")

    for app in "${app_candidates[@]}"; do
        if [[ -d "$app" ]]; then
            native_candidates+=("$app/Contents/MacOS/renode")
            exe_candidates+=("$app/Contents/MacOS/bin/Renode.exe")
        fi
    done

    path_bin="$(command -v renode 2>/dev/null || true)"
    [[ -n "$path_bin" ]] && native_candidates+=("$path_bin")

    for cand in "${native_candidates[@]}"; do
        if [[ -n "$cand" && -x "$cand" ]]; then
            echo "native:$cand"
            return 0
        fi
    done

    for cand in "${exe_candidates[@]}"; do
        if [[ -n "$cand" && -f "$cand" ]]; then
            echo "mono:$cand"
            return 0
        fi
    done

    echo "ERROR: Renode binary not found. Set RENODE_BIN or RENODE_APP, or install Renode." >&2
    exit 1
}

RENODE_MATCH="$(find_renode)"
RENODE_MODE="${RENODE_MATCH%%:*}"
RENODE_BIN="${RENODE_MATCH#*:}"

OUTDIR_WAS_SET=false
if [[ -n "${BC280_RENODE_OUTDIR:-}" ]]; then
    OUTDIR="$BC280_RENODE_OUTDIR"
    OUTDIR_WAS_SET=true
else
    OUTDIR="$(mktemp -d 2>/dev/null || mktemp -d -t bc280-renode-smoke)"
fi

UART_LOG="$OUTDIR/uart1_tx.log"
RENODE_LOG="$OUTDIR/renode.log"

mkdir -p "$OUTDIR"

SMOKE_RESC="$OUTDIR/smoke_autogen.resc"
cat >"$SMOKE_RESC" <<EOF
# Auto-generated by scripts/renode_smoke.sh
include @$RENODE_RESC
start
emulation RunFor "${SIM_SECONDS}s"
cpu PC
cpu SP
quit
EOF

echo "[smoke] building open-firmware (Meson/Ninja cross build)" >&2
(
    cd "$ROOT_DIR"
    meson setup build --cross-file cross/arm-none-eabi-clang.txt || \
        meson setup --reconfigure build --cross-file cross/arm-none-eabi-clang.txt
    ninja -C build
)

if [[ ! -f "$ROOT_DIR/build/open_firmware.bin" ]]; then
    echo "ERROR: expected build/open_firmware.bin to exist after build" >&2
    exit 1
fi

rm -f "$UART_LOG"

echo "[smoke] using Renode ($RENODE_MODE): $RENODE_BIN" >&2
echo "[smoke] log dir: $OUTDIR" >&2

if [[ "$RENODE_MODE" == "mono" ]]; then
    MONO_BIN="$(command -v mono64 2>/dev/null || true)"
    if [[ -z "$MONO_BIN" ]]; then
        echo "ERROR: mono64 not found (required for Renode.exe). Install Mono or use a native Renode binary." >&2
        exit 1
    fi
    RENODE_MACOS_DIR="$(cd "$(dirname "$RENODE_BIN")/.." && pwd)"
    DYLD_FALLBACK_LIBRARY_PATH="${RENODE_MACOS_DIR}:/Library/Frameworks/Mono.framework/Versions/Current/lib:/lib:/usr/lib"
    export DYLD_FALLBACK_LIBRARY_PATH
    BC280_REPO_ROOT="$ROOT_DIR" BC280_RENODE_OUTDIR="$OUTDIR" BC280_LCD_OUTDIR="$OUTDIR" "$MONO_BIN" "$RENODE_BIN" --disable-xwt \
        -e "include @$SMOKE_RESC" \
        >"$RENODE_LOG" 2>&1 &
else
    BC280_REPO_ROOT="$ROOT_DIR" BC280_RENODE_OUTDIR="$OUTDIR" BC280_LCD_OUTDIR="$OUTDIR" "$RENODE_BIN" --disable-xwt \
        -e "include @$SMOKE_RESC" \
        >"$RENODE_LOG" 2>&1 &
fi
RENODE_PID=$!

cleanup() {
    kill "$RENODE_PID" >/dev/null 2>&1 || true
    wait "$RENODE_PID" >/dev/null 2>&1 || true
    if ! $OUTDIR_WAS_SET; then
        rm -rf "$OUTDIR"
    fi
}
trap cleanup EXIT

found_tick=0
elapsed=0

# Give Renode a brief moment to finish CPU start before polling the UART log.
if [[ "$LAUNCH_GRACE_MS" -gt 0 ]]; then
    sleep "0.$LAUNCH_GRACE_MS"
fi

while (( elapsed < TIMEOUT_SECONDS )); do
    if [[ -f "$UART_LOG" ]]; then
        if grep -Fq "[open-fw] t=" "$UART_LOG"; then
            found_tick=1
        fi
        if (( found_tick )); then
            break
        fi
    fi
    sleep 1
    elapsed=$((elapsed + 1))
done

if ! (( found_tick )); then
    echo "[smoke] FAIL: missing UART markers after ${TIMEOUT_SECONDS}s" >&2
    echo "----- UART1 tail -----" >&2
    if [[ -f "$UART_LOG" ]]; then
        tail -n 40 "$UART_LOG" >&2
    else
        echo "(no uart log produced)" >&2
    fi
    echo "----- Renode log tail -----" >&2
    if [[ -f "$RENODE_LOG" ]]; then
        tail -n 60 "$RENODE_LOG" >&2
    else
        echo "(no renode log)" >&2
    fi
    exit 1
fi

echo "[smoke] PASS: observed status line in ${elapsed}s" >&2
exit 0
