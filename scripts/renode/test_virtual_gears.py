#!/usr/bin/env python3
"""Renode regression for virtual gears + cadence-friendly bias.

Coverage:
- linear gear table scaling of assist output
- exponential gear spacing
- cadence-friendly taper above target band
- gear up/down button edges (bit4 up, bit5 down)

Usage:
  BC280_UART1_PTY=/tmp/uart1 ./scripts/renode/test_virtual_gears.py
"""

import os
import sys
import time
from typing import List

from uart_client import UARTClient, ProtocolError

PORT = os.environ.get("BC280_UART1_PTY", "/tmp/uart1")


def expect(cond: bool, msg: str) -> None:
    if not cond:
        raise AssertionError(msg)


def gen_scales(count: int, min_q15: int, max_q15: int, shape: int) -> List[int]:
    if count == 1:
        return [min_q15]
    out: List[int] = []
    for i in range(count):
        if shape == 1:
            num = (max_q15 - min_q15) * i * i
            den = (count - 1) * (count - 1)
            out.append(min_q15 + num // den)
        else:
            num = (max_q15 - min_q15) * i
            den = count - 1
            out.append(min_q15 + num // den)
    return out


def cadence_bias(expected_target: int, band: int, min_bias: int, cadence: int) -> int:
    if band == 0 or cadence <= expected_target:
        return 32768
    delta = cadence - expected_target
    if delta >= band:
        return min_bias
    drop = 32768 - min_bias
    scaled = (drop * delta) // band
    return max(min_bias, 32768 - scaled)


def gear_step(client: UARTClient, base_args: dict, buttons: int) -> None:
    args = base_args.copy()
    args["buttons"] = buttons
    client.set_state(**args)
    # clear edge
    args["buttons"] = 0
    client.set_state(**args)


def main() -> int:
    for _ in range(50):
        if os.path.exists(PORT):
            break
        time.sleep(0.1)
    if not os.path.exists(PORT):
        sys.stderr.write(f"UART PTY not found at {PORT}\n")
        return 1

    client = UARTClient(PORT, baud=115200, timeout=0.5)
    base_state = dict(rpm=200, torque=80, speed_dmph=120, soc=90, err=0, cadence_rpm=80, throttle_pct=80, brake=0)
    try:
        client.ping()
        client.set_profile(1, persist=False)  # trail profile

        # Linear table, generated by firmware (no explicit scales).
        count = 4
        min_q15 = 16384  # 0.5x
        max_q15 = 49152  # 1.5x
        client.set_gears(count=count, shape=0, min_q15=min_q15, max_q15=max_q15, scales=None)
        scales = gen_scales(count, min_q15, max_q15, 0)

        # Start at gear 1, then step up to 4 verifying scaling.
        gear = 1
        client.set_state(**base_state)
        for _ in range(3):
            gear_step(client, base_state, buttons=0x10)  # gear up
            gear += 1
            dbg = client.debug_state()
            expect(dbg.virtual_gear == gear, f"gear should be {gear}")
            base_power = (base_state["throttle_pct"] * 8) + (base_state["torque"] // 4)
            gear_limit = (dbg.curve_power_w * scales[gear - 1] + (1 << 14)) >> 15
            expect(dbg.gear_limit_power_w == gear_limit, "gear_limit_power mismatch")
            expected_cmd = min(base_power, gear_limit, dbg.cap_power_w)
            expect(dbg.cmd_power_w == expected_cmd, "cmd_power_w mismatch for linear gear")

        # Gear down once and verify.
        gear_step(client, base_state, buttons=0x20)
        gear -= 1
        dbg = client.debug_state()
        expect(dbg.virtual_gear == gear, "gear down failed")

        # Exponential spacing check.
        min_q15 = 16384
        max_q15 = 65535
        client.set_gears(count=4, shape=1, min_q15=min_q15, max_q15=max_q15, scales=None)
        scales = gen_scales(4, min_q15, max_q15, 1)
        gear = 1
        client.set_state(**base_state)
        for _ in range(3):
            gear_step(client, base_state, buttons=0x10)
            gear += 1
            dbg = client.debug_state()
            expect(dbg.virtual_gear == gear, "exp gear index")
            gear_limit = (dbg.curve_power_w * scales[gear - 1] + (1 << 14)) >> 15
            expect(dbg.gear_limit_power_w == gear_limit, "exp gear_limit_power mismatch")

        # Cadence-friendly taper.
        client.set_gears(count=1, shape=0, min_q15=32768, max_q15=32768, scales=[32768])
        client.set_cadence_bias(True, target_rpm=80, band_rpm=20, min_bias_q15=16384)
        for cad in (70, 90, 110):
            state = base_state.copy()
            state["cadence_rpm"] = cad
            client.set_state(**state)
            dbg = client.debug_state()
            bias = cadence_bias(80, 20, 16384, cad)
            expect(dbg.cadence_bias_q15 == bias, "cadence bias q15 mismatch")
            gear_limit = (dbg.curve_power_w * 32768 + (1 << 14)) >> 15
            biased_limit = (gear_limit * bias + (1 << 14)) >> 15
            base_power = (state["throttle_pct"] * 8) + (state["torque"] // 4)
            expected_cmd = min(base_power, biased_limit, dbg.cap_power_w)
            expect(dbg.cmd_power_w == expected_cmd, f"cadence taper cmd_power mismatch at {cad}rpm")

        print("PASS: virtual gears + cadence bias")
        return 0
    except (ProtocolError, AssertionError) as e:
        sys.stderr.write(f"FAIL: {e}\n")
        return 1
    finally:
        client.close()


if __name__ == "__main__":
    raise SystemExit(main())
